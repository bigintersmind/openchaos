name: Merge top-voted PR weekly

on:
  schedule:
    - cron: "0 12 * * 0"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  merge-top-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Merge highest-voted mergeable PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const MARKER = '<!-- vote-integrity-watchdog -->';

            // Get the most recent CODE CHANGED timestamp for a PR
            async function getCodeChangeCutoff(prNumber) {
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100
              });

              const codeChangedComments = comments.data.filter(
                c => c.user.login === 'github-actions[bot]' &&
                     c.body.includes(MARKER) &&
                     c.body.includes('**CODE CHANGED**')
              );

              if (codeChangedComments.length === 0) {
                return null; // No code changes — all votes count
              }

              // Find the most recent CODE CHANGED comment
              const latest = codeChangedComments[codeChangedComments.length - 1];
              const match = latest.body.match(/Timestamp: (\d{4}-\d{2}-\d{2}T[\d:.]+Z)/);
              return match ? match[1] : null;
            }

            // Fetch all open PRs with vote-integrity-aware net vote counts
            async function getRankedPRs() {
              const prs = await github.rest.pulls.list({
                owner,
                repo,
                state: "open",
                per_page: 100
              });

              const prsWithVotes = await Promise.all(
                prs.data.map(async (pr) => {
                  // Fetch all reactions with timestamps
                  let allReactions = [];
                  let page = 1;
                  while (true) {
                    const resp = await github.rest.reactions.listForIssue({
                      owner,
                      repo,
                      issue_number: pr.number,
                      per_page: 100,
                      page
                    });
                    allReactions = allReactions.concat(resp.data);
                    if (resp.data.length < 100) break;
                    page++;
                  }

                  // Get code change cutoff timestamp
                  const cutoff = await getCodeChangeCutoff(pr.number);

                  // Filter reactions by cutoff if applicable
                  let validReactions = allReactions;
                  if (cutoff) {
                    const cutoffTime = new Date(cutoff).getTime();
                    validReactions = allReactions.filter(
                      r => new Date(r.created_at).getTime() > cutoffTime
                    );
                    console.log(`PR #${pr.number}: cutoff ${cutoff}, total reactions: ${allReactions.length}, valid: ${validReactions.length}`);
                  }

                  // Net votes: thumbs up minus thumbs down
                  const thumbsUp = validReactions.filter(r => r.content === '+1').length;
                  const thumbsDown = validReactions.filter(r => r.content === '-1').length;
                  const votes = thumbsUp - thumbsDown;

                  return {
                    number: pr.number,
                    title: pr.title,
                    author: pr.user.login,
                    createdAt: pr.created_at,
                    headSha: pr.head.sha,
                    votes
                  };
                })
              );

              // Sort by net votes descending, then by newest first for tiebreaker
              prsWithVotes.sort((a, b) =>
                (b.votes - a.votes) ||
                (new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
              );

              return prsWithVotes;
            }

            const rankedPRs = await getRankedPRs();
            if (rankedPRs.length === 0) {
              console.log("No open PRs found.");
              return;
            }

            console.log("=== PR Rankings ===");
            for (const pr of rankedPRs) {
              console.log(`#${pr.number} — ${pr.votes} net votes — "${pr.title}" by @${pr.author}`);
            }
            console.log("===================\n");

            // Iterate through ranked PRs, merge the first mergeable one
            for (const pr of rankedPRs) {
              if (pr.votes <= 0) {
                console.log(`PR #${pr.number} has ${pr.votes} net votes — stopping (no positive-vote PRs remain).`);
                break;
              }

              console.log(`\nEvaluating PR #${pr.number} (${pr.votes} net votes)...`);

              // Check mergeable status
              const detail = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number
              });

              // GitHub may return null if mergeability hasn't been computed yet — retry once
              let mergeable = detail.data.mergeable;
              if (mergeable === null) {
                console.log(`  Mergeability not yet computed, retrying...`);
                await new Promise(r => setTimeout(r, 3000));
                const retry = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pr.number
                });
                mergeable = retry.data.mergeable;
              }

              if (!mergeable) {
                console.log(`  PR #${pr.number} has merge conflicts — skipping.`);
                continue;
              }

              // Check CI status
              const checks = await github.rest.repos.getCombinedStatusForRef({
                owner,
                repo,
                ref: detail.data.head.sha
              });
              const checkRuns = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: detail.data.head.sha
              });
              const allChecksPassed = checkRuns.data.check_runs.every(
                cr => cr.conclusion === 'success' || cr.conclusion === 'skipped'
              );

              if (checks.data.state === 'failure' || !allChecksPassed) {
                console.log(`  PR #${pr.number} has failing CI checks — skipping.`);
                continue;
              }

              // All clear — merge it
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pr.number,
                merge_method: 'squash'
              });
              console.log(`\nMerged PR #${pr.number} by @${pr.author}: "${pr.title}" (${pr.votes} net votes)`);
              return;
            }

            console.log("\nNo mergeable PR with positive votes found.");
